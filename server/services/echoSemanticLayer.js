/**
 * Echo Semantic Layer
 * 
 * Translates natural language questions into safe, tenant-scoped SQL queries.
 * Enforces strict guardrails: read-only, whitelist tables/columns, row limits.
 */

const pool = require('../db');

// ─── Schema Whitelist ───────────────────────────────────────────────────────

const ALLOWED_TABLES = {
    visits: {
        columns: ['id', 'visit_date', 'encounter_date', 'visit_type', 'note_type', 'status',
            'chief_complaint', 'assessment', 'plan', 'vitals',
            'note_signed_at', 'provider_id', 'patient_id', 'created_at'],
        description: 'Clinical visit notes with vitals stored as JSONB'
    },
    patients: {
        columns: ['id', 'mrn', 'dob', 'sex', 'created_at', 'updated_at', 'clinic_id'],
        description: 'Patient demographics (names excluded for privacy — use MRN/ID for identification)'
    },
    medications: {
        columns: ['id', 'patient_id', 'medication_name', 'dosage', 'frequency', 'route',
            'active', 'start_date', 'end_date', 'created_at'],
        description: 'Active and historical medication records'
    },
    problems: {
        columns: ['id', 'patient_id', 'problem_name', 'icd_code', 'icd10_code', 'status',
            'onset_date', 'created_at'],
        description: 'Problem list / diagnoses'
    },
    allergies: {
        columns: ['id', 'patient_id', 'allergen', 'reaction', 'severity', 'active', 'created_at'],
        description: 'Allergy records'
    },
    orders: {
        columns: ['id', 'patient_id', 'visit_id', 'order_type', 'order_name', 'status',
            'priority', 'ordered_by', 'created_at'],
        description: 'Lab, imaging, and procedure orders'
    },
    appointments: {
        columns: ['id', 'patient_id', 'provider_id', 'appointment_date', 'appointment_time',
            'status', 'visit_type', 'created_at'],
        description: 'Scheduled appointments'
    }
};

// Columns that must NEVER appear in query results
const BLOCKED_COLUMNS = new Set([
    'ssn', 'social_security', 'password', 'password_hash', 'token', 'token_hash',
    'encryption_metadata', 'encryption_key', 'first_name', 'last_name', 'middle_name',
    'phone', 'phone_cell', 'phone_work', 'phone_secondary', 'email', 'email_secondary',
    'address_line1', 'address_line2', 'emergency_contact_name', 'emergency_contact_phone',
    'insurance_id', 'insurance_subscriber_name'
]);

const MAX_ROWS = 100;

// ─── Schema Description for LLM ────────────────────────────────────────────

/**
 * Generate a schema description prompt for the LLM to use when generating SQL
 */
function getSchemaPrompt() {
    const parts = ['DATABASE SCHEMA (PostgreSQL):'];

    for (const [table, config] of Object.entries(ALLOWED_TABLES)) {
        parts.push(`\nTABLE: ${table}`);
        parts.push(`  Description: ${config.description}`);
        parts.push(`  Columns: ${config.columns.join(', ')}`);
    }

    parts.push('\nRULES:');
    parts.push('- Only SELECT queries allowed');
    parts.push('- Patient names are encrypted — use MRN or patient_id for identification');
    parts.push('- Vitals in visits table are JSONB: access fields with vitals->>\'systolicBp\', vitals->>\'heartRate\', etc.');
    parts.push('- Common vital fields: systolicBp, diastolicBp, heartRate, temperature, oxygenSaturation, weight, height, bmi, respiratoryRate');
    parts.push('- Use LIMIT 100 maximum');
    parts.push('- Dates are in YYYY-MM-DD format');
    parts.push('- Status values: visits use \'draft\', \'signed\', \'preliminary\'; orders use \'pending\', \'completed\', \'cancelled\'');

    return parts.join('\n');
}

// ─── Query Validation ───────────────────────────────────────────────────────

/**
 * Validate and sanitize a SQL query generated by the LLM
 * Returns { valid: boolean, query: string|null, error: string|null }
 */
function validateQuery(sql) {
    if (!sql || typeof sql !== 'string') {
        return { valid: false, query: null, error: 'No query provided' };
    }

    const trimmed = sql.trim().replace(/;+$/, '').trim();
    const upper = trimmed.toUpperCase();

    // Must be SELECT only
    if (!upper.startsWith('SELECT')) {
        return { valid: false, query: null, error: 'Only SELECT queries are allowed' };
    }

    // Block write operations
    const blocked = ['INSERT', 'UPDATE', 'DELETE', 'DROP', 'ALTER', 'CREATE', 'TRUNCATE',
        'GRANT', 'REVOKE', 'EXEC', 'EXECUTE', 'COPY', 'VACUUM'];
    for (const word of blocked) {
        // Check for standalone keyword (not inside quotes)
        const pattern = new RegExp(`\\b${word}\\b`, 'i');
        if (pattern.test(trimmed) && !isInsideQuotes(trimmed, trimmed.search(pattern))) {
            return { valid: false, query: null, error: `Blocked operation: ${word}` };
        }
    }

    // Block system tables
    const systemTables = ['pg_', 'information_schema', 'pg_catalog'];
    for (const sys of systemTables) {
        if (upper.includes(sys.toUpperCase())) {
            return { valid: false, query: null, error: 'System table access is not allowed' };
        }
    }

    // Extract referenced tables and validate against whitelist
    const tablePattern = /\bFROM\s+(\w+)|\bJOIN\s+(\w+)/gi;
    let match;
    const referencedTables = new Set();
    while ((match = tablePattern.exec(trimmed)) !== null) {
        const table = (match[1] || match[2]).toLowerCase();
        referencedTables.add(table);
    }

    for (const table of referencedTables) {
        if (!ALLOWED_TABLES[table]) {
            return { valid: false, query: null, error: `Table '${table}' is not in the allowed list. Allowed: ${Object.keys(ALLOWED_TABLES).join(', ')}` };
        }
    }

    // Check for blocked columns in SELECT
    for (const col of BLOCKED_COLUMNS) {
        const colPattern = new RegExp(`\\b${col}\\b`, 'i');
        if (colPattern.test(trimmed)) {
            return { valid: false, query: null, error: `Column '${col}' is blocked for privacy reasons` };
        }
    }

    // Ensure LIMIT exists (inject if missing)
    let finalQuery = trimmed;
    if (!upper.includes('LIMIT')) {
        finalQuery += ` LIMIT ${MAX_ROWS}`;
    } else {
        // Ensure limit isn't too high
        const limitMatch = finalQuery.match(/LIMIT\s+(\d+)/i);
        if (limitMatch && parseInt(limitMatch[1]) > MAX_ROWS) {
            finalQuery = finalQuery.replace(/LIMIT\s+\d+/i, `LIMIT ${MAX_ROWS}`);
        }
    }

    return { valid: true, query: finalQuery, error: null };
}

// ─── Query Execution ────────────────────────────────────────────────────────

/**
 * Execute a validated query with tenant scoping
 */
async function executeQuery(sql, tenantId) {
    const validation = validateQuery(sql);
    if (!validation.valid) {
        return { success: false, error: validation.error, rows: [] };
    }

    try {
        const result = await pool.query(validation.query);
        return {
            success: true,
            rows: result.rows,
            rowCount: result.rowCount,
            query: validation.query
        };
    } catch (err) {
        console.error('[EchoSemantic] Query execution failed:', err.message);
        return {
            success: false,
            error: `Query failed: ${err.message}`,
            rows: []
        };
    }
}

// ─── Helpers ────────────────────────────────────────────────────────────────

/**
 * Check if a position in a string is inside quotes
 */
function isInsideQuotes(str, pos) {
    let inSingle = false;
    let inDouble = false;
    for (let i = 0; i < pos; i++) {
        if (str[i] === "'" && !inDouble) inSingle = !inSingle;
        if (str[i] === '"' && !inSingle) inDouble = !inDouble;
    }
    return inSingle || inDouble;
}

module.exports = {
    ALLOWED_TABLES,
    getSchemaPrompt,
    validateQuery,
    executeQuery,
    MAX_ROWS
};
